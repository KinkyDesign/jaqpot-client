/*
 * Jaqpot API
 * Jaqpot v4 (Quattro) is the 4th version of a YAQP, a RESTful web service which can be used to train machine learning models and use them to obtain toxicological predictions for given chemical compounds or engineered nano materials. The project is written in Java8 and JEE7.
 *
 * OpenAPI spec version: 4.0.3
 * Contact: hampos@me.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package jaqpot.client.api;

import jaqpot.client.ApiCallback;
import jaqpot.client.ApiClient;
import jaqpot.client.ApiException;
import jaqpot.client.ApiResponse;
import jaqpot.client.Configuration;
import jaqpot.client.Pair;
import jaqpot.client.ProgressRequestBody;
import jaqpot.client.ProgressResponseBody;

import java.io.IOException;


import jaqpot.client.model.BibTeX;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class BibtexApi {
    private ApiClient apiClient;

    public BibtexApi() {
        this(Configuration.getDefaultApiClient());
    }

    public BibtexApi(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return apiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.apiClient = apiClient;
    }

    /* Build call for createBibTeX */
    private com.squareup.okhttp.Call createBibTeXCall(BibTeX body, String subjectid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/bibtex".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (subjectid != null)
        localVarHeaderParams.put("subjectid", apiClient.parameterToString(subjectid));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/uri-list"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "POST", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createBibTeXValidateBeforeCall(BibTeX body, String subjectid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling createBibTeX(Async)");
        }
        
        
        com.squareup.okhttp.Call call = createBibTeXCall(body, subjectid, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Creates a new BibTeX entry
     * Creates a new BibTeX entry which is assigned a random unique ID. Clients are not allowed to specify a custom ID when using this method. Clients should use PUT instead in such a case.
     * @param body BibTeX in JSON representation compliant with the BibTeX specifications. Malformed BibTeX entries with missing fields will not be accepted. (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void createBibTeX(BibTeX body, String subjectid) throws ApiException {
        createBibTeXWithHttpInfo(body, subjectid);
    }

    /**
     * Creates a new BibTeX entry
     * Creates a new BibTeX entry which is assigned a random unique ID. Clients are not allowed to specify a custom ID when using this method. Clients should use PUT instead in such a case.
     * @param body BibTeX in JSON representation compliant with the BibTeX specifications. Malformed BibTeX entries with missing fields will not be accepted. (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> createBibTeXWithHttpInfo(BibTeX body, String subjectid) throws ApiException {
        com.squareup.okhttp.Call call = createBibTeXValidateBeforeCall(body, subjectid, null, null);
        return apiClient.execute(call);
    }

    /**
     * Creates a new BibTeX entry (asynchronously)
     * Creates a new BibTeX entry which is assigned a random unique ID. Clients are not allowed to specify a custom ID when using this method. Clients should use PUT instead in such a case.
     * @param body BibTeX in JSON representation compliant with the BibTeX specifications. Malformed BibTeX entries with missing fields will not be accepted. (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call createBibTeXAsync(BibTeX body, String subjectid, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createBibTeXValidateBeforeCall(body, subjectid, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /* Build call for createBibTeXGivenID */
    private com.squareup.okhttp.Call createBibTeXGivenIDCall(String id, BibTeX body, String subjectid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/bibtex/{id}".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (subjectid != null)
        localVarHeaderParams.put("subjectid", apiClient.parameterToString(subjectid));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/uri-list"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "PUT", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call createBibTeXGivenIDValidateBeforeCall(String id, BibTeX body, String subjectid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling createBibTeXGivenID(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling createBibTeXGivenID(Async)");
        }
        
        
        com.squareup.okhttp.Call call = createBibTeXGivenIDCall(id, body, subjectid, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Places a new BibTeX entry at a particular URI
     * Creates a new BibTeX entry at the specified URI. If a BibTeX already exists at this URI,it will be replaced. If, instead, no BibTeX is stored under the specified URI, a new BibTeX entry will be created. Notice that authentication, authorization and accounting (quota) restrictions may apply.
     * @param id ID of the BibTeX. (required)
     * @param body BibTeX in JSON (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void createBibTeXGivenID(String id, BibTeX body, String subjectid) throws ApiException {
        createBibTeXGivenIDWithHttpInfo(id, body, subjectid);
    }

    /**
     * Places a new BibTeX entry at a particular URI
     * Creates a new BibTeX entry at the specified URI. If a BibTeX already exists at this URI,it will be replaced. If, instead, no BibTeX is stored under the specified URI, a new BibTeX entry will be created. Notice that authentication, authorization and accounting (quota) restrictions may apply.
     * @param id ID of the BibTeX. (required)
     * @param body BibTeX in JSON (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> createBibTeXGivenIDWithHttpInfo(String id, BibTeX body, String subjectid) throws ApiException {
        com.squareup.okhttp.Call call = createBibTeXGivenIDValidateBeforeCall(id, body, subjectid, null, null);
        return apiClient.execute(call);
    }

    /**
     * Places a new BibTeX entry at a particular URI (asynchronously)
     * Creates a new BibTeX entry at the specified URI. If a BibTeX already exists at this URI,it will be replaced. If, instead, no BibTeX is stored under the specified URI, a new BibTeX entry will be created. Notice that authentication, authorization and accounting (quota) restrictions may apply.
     * @param id ID of the BibTeX. (required)
     * @param body BibTeX in JSON (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call createBibTeXGivenIDAsync(String id, BibTeX body, String subjectid, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = createBibTeXGivenIDValidateBeforeCall(id, body, subjectid, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /* Build call for deleteBibTeX */
    private com.squareup.okhttp.Call deleteBibTeXCall(String id, String subjectid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/bibtex/{id}".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (subjectid != null)
        localVarHeaderParams.put("subjectid", apiClient.parameterToString(subjectid));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/uri-list"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "DELETE", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call deleteBibTeXValidateBeforeCall(String id, String subjectid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling deleteBibTeX(Async)");
        }
        
        
        com.squareup.okhttp.Call call = deleteBibTeXCall(id, subjectid, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Deletes a particular BibTeX resource
     * Deletes a BibTeX resource of a given ID. The method is idempondent, that is, it can be used more than once without triggering an exception/error. If the BibTeX does not exist, the method will return without errors. Authentication and authorization requirements apply, so clients that are not authenticated with a valid token or do not have sufficient priviledges will not be able to delete a BibTeX using this method.
     * @param id ID of the BibTeX. (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void deleteBibTeX(String id, String subjectid) throws ApiException {
        deleteBibTeXWithHttpInfo(id, subjectid);
    }

    /**
     * Deletes a particular BibTeX resource
     * Deletes a BibTeX resource of a given ID. The method is idempondent, that is, it can be used more than once without triggering an exception/error. If the BibTeX does not exist, the method will return without errors. Authentication and authorization requirements apply, so clients that are not authenticated with a valid token or do not have sufficient priviledges will not be able to delete a BibTeX using this method.
     * @param id ID of the BibTeX. (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> deleteBibTeXWithHttpInfo(String id, String subjectid) throws ApiException {
        com.squareup.okhttp.Call call = deleteBibTeXValidateBeforeCall(id, subjectid, null, null);
        return apiClient.execute(call);
    }

    /**
     * Deletes a particular BibTeX resource (asynchronously)
     * Deletes a BibTeX resource of a given ID. The method is idempondent, that is, it can be used more than once without triggering an exception/error. If the BibTeX does not exist, the method will return without errors. Authentication and authorization requirements apply, so clients that are not authenticated with a valid token or do not have sufficient priviledges will not be able to delete a BibTeX using this method.
     * @param id ID of the BibTeX. (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call deleteBibTeXAsync(String id, String subjectid, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = deleteBibTeXValidateBeforeCall(id, subjectid, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /* Build call for getBibTeX */
    private com.squareup.okhttp.Call getBibTeXCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/bibtex/{id}".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/uri-list"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call getBibTeXValidateBeforeCall(String id, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling getBibTeX(Async)");
        }
        
        
        com.squareup.okhttp.Call call = getBibTeXCall(id, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Returns BibTeX entry
     * Finds and returns a BibTeX by ID
     * @param id ID of the BibTeX (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void getBibTeX(String id) throws ApiException {
        getBibTeXWithHttpInfo(id);
    }

    /**
     * Returns BibTeX entry
     * Finds and returns a BibTeX by ID
     * @param id ID of the BibTeX (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> getBibTeXWithHttpInfo(String id) throws ApiException {
        com.squareup.okhttp.Call call = getBibTeXValidateBeforeCall(id, null, null);
        return apiClient.execute(call);
    }

    /**
     * Returns BibTeX entry (asynchronously)
     * Finds and returns a BibTeX by ID
     * @param id ID of the BibTeX (required)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call getBibTeXAsync(String id, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = getBibTeXValidateBeforeCall(id, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /* Build call for listBibTeXs */
    private com.squareup.okhttp.Call listBibTeXsCall(String bibtype, String creator, String query, Integer start, Integer max, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = null;
        
        // create path and map variables
        String localVarPath = "/bibtex".replaceAll("\\{format\\}","json");

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        if (bibtype != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "bibtype", bibtype));
        if (creator != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "creator", creator));
        if (query != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "query", query));
        if (start != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "start", start));
        if (max != null)
        localVarQueryParams.addAll(apiClient.parameterToPairs("", "max", max));

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/uri-list"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "GET", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call listBibTeXsValidateBeforeCall(String bibtype, String creator, String query, Integer start, Integer max, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        
        com.squareup.okhttp.Call call = listBibTeXsCall(bibtype, creator, query, start, max, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Finds all BibTeX entries
     * Finds all BibTeX entries in the DB of Jaqpot and returns them in a list
     * @param bibtype BibTeX type of entry (optional, default to Entry)
     * @param creator Creator of the BibTeX entry (optional)
     * @param query Generic query (e.g., Article title, journal name, etc) (optional)
     * @param start start (optional, default to 0)
     * @param max max (optional, default to 10)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void listBibTeXs(String bibtype, String creator, String query, Integer start, Integer max) throws ApiException {
        listBibTeXsWithHttpInfo(bibtype, creator, query, start, max);
    }

    /**
     * Finds all BibTeX entries
     * Finds all BibTeX entries in the DB of Jaqpot and returns them in a list
     * @param bibtype BibTeX type of entry (optional, default to Entry)
     * @param creator Creator of the BibTeX entry (optional)
     * @param query Generic query (e.g., Article title, journal name, etc) (optional)
     * @param start start (optional, default to 0)
     * @param max max (optional, default to 10)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> listBibTeXsWithHttpInfo(String bibtype, String creator, String query, Integer start, Integer max) throws ApiException {
        com.squareup.okhttp.Call call = listBibTeXsValidateBeforeCall(bibtype, creator, query, start, max, null, null);
        return apiClient.execute(call);
    }

    /**
     * Finds all BibTeX entries (asynchronously)
     * Finds all BibTeX entries in the DB of Jaqpot and returns them in a list
     * @param bibtype BibTeX type of entry (optional, default to Entry)
     * @param creator Creator of the BibTeX entry (optional)
     * @param query Generic query (e.g., Article title, journal name, etc) (optional)
     * @param start start (optional, default to 0)
     * @param max max (optional, default to 10)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call listBibTeXsAsync(String bibtype, String creator, String query, Integer start, Integer max, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = listBibTeXsValidateBeforeCall(bibtype, creator, query, start, max, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
    /* Build call for modifyBibTeX */
    private com.squareup.okhttp.Call modifyBibTeXCall(String id, String body, String subjectid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        Object localVarPostBody = body;
        
        // create path and map variables
        String localVarPath = "/bibtex/{id}".replaceAll("\\{format\\}","json")
        .replaceAll("\\{" + "id" + "\\}", apiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();

        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        if (subjectid != null)
        localVarHeaderParams.put("subjectid", apiClient.parameterToString(subjectid));

        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
            "application/json", "text/uri-list"
        };
        final String localVarAccept = apiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) localVarHeaderParams.put("Accept", localVarAccept);

        final String[] localVarContentTypes = {
            "application/json-patch+json"
        };
        final String localVarContentType = apiClient.selectHeaderContentType(localVarContentTypes);
        localVarHeaderParams.put("Content-Type", localVarContentType);

        if(progressListener != null) {
            apiClient.getHttpClient().networkInterceptors().add(new com.squareup.okhttp.Interceptor() {
                @Override
                public com.squareup.okhttp.Response intercept(com.squareup.okhttp.Interceptor.Chain chain) throws IOException {
                    com.squareup.okhttp.Response originalResponse = chain.proceed(chain.request());
                    return originalResponse.newBuilder()
                    .body(new ProgressResponseBody(originalResponse.body(), progressListener))
                    .build();
                }
            });
        }

        String[] localVarAuthNames = new String[] {  };
        return apiClient.buildCall(localVarPath, "PATCH", localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarAuthNames, progressRequestListener);
    }
    
    @SuppressWarnings("rawtypes")
    private com.squareup.okhttp.Call modifyBibTeXValidateBeforeCall(String id, String body, String subjectid, final ProgressResponseBody.ProgressListener progressListener, final ProgressRequestBody.ProgressRequestListener progressRequestListener) throws ApiException {
        
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling modifyBibTeX(Async)");
        }
        
        // verify the required parameter 'body' is set
        if (body == null) {
            throw new ApiException("Missing the required parameter 'body' when calling modifyBibTeX(Async)");
        }
        
        
        com.squareup.okhttp.Call call = modifyBibTeXCall(id, body, subjectid, progressListener, progressRequestListener);
        return call;

        
        
        
        
    }

    /**
     * Modifies a particular BibTeX resource
     * Modifies (applies a patch on) a BibTeX resource of a given ID. This implementation of PATCH follows the RFC 6902 proposed standard. See https://tools.ietf.org/rfc/rfc6902.txt for details.
     * @param id ID of an existing BibTeX. (required)
     * @param body The patch in JSON according to the RFC 6902 specs (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public void modifyBibTeX(String id, String body, String subjectid) throws ApiException {
        modifyBibTeXWithHttpInfo(id, body, subjectid);
    }

    /**
     * Modifies a particular BibTeX resource
     * Modifies (applies a patch on) a BibTeX resource of a given ID. This implementation of PATCH follows the RFC 6902 proposed standard. See https://tools.ietf.org/rfc/rfc6902.txt for details.
     * @param id ID of an existing BibTeX. (required)
     * @param body The patch in JSON according to the RFC 6902 specs (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     */
    public ApiResponse<Void> modifyBibTeXWithHttpInfo(String id, String body, String subjectid) throws ApiException {
        com.squareup.okhttp.Call call = modifyBibTeXValidateBeforeCall(id, body, subjectid, null, null);
        return apiClient.execute(call);
    }

    /**
     * Modifies a particular BibTeX resource (asynchronously)
     * Modifies (applies a patch on) a BibTeX resource of a given ID. This implementation of PATCH follows the RFC 6902 proposed standard. See https://tools.ietf.org/rfc/rfc6902.txt for details.
     * @param id ID of an existing BibTeX. (required)
     * @param body The patch in JSON according to the RFC 6902 specs (required)
     * @param subjectid Clients need to authenticate in order to create resources on the server (optional)
     * @param callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     */
    public com.squareup.okhttp.Call modifyBibTeXAsync(String id, String body, String subjectid, final ApiCallback<Void> callback) throws ApiException {

        ProgressResponseBody.ProgressListener progressListener = null;
        ProgressRequestBody.ProgressRequestListener progressRequestListener = null;

        if (callback != null) {
            progressListener = new ProgressResponseBody.ProgressListener() {
                @Override
                public void update(long bytesRead, long contentLength, boolean done) {
                    callback.onDownloadProgress(bytesRead, contentLength, done);
                }
            };

            progressRequestListener = new ProgressRequestBody.ProgressRequestListener() {
                @Override
                public void onRequestProgress(long bytesWritten, long contentLength, boolean done) {
                    callback.onUploadProgress(bytesWritten, contentLength, done);
                }
            };
        }

        com.squareup.okhttp.Call call = modifyBibTeXValidateBeforeCall(id, body, subjectid, progressListener, progressRequestListener);
        apiClient.executeAsync(call, callback);
        return call;
    }
}
